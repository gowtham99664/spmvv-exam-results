from rest_framework import status, generics
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import authenticate
from django.db import transaction
from django.utils import timezone
from .models import User, Result, Subject, Notification, AuditLog
from .serializers import (
    UserRegistrationSerializer, PasswordChangeSerializer,
    ResultSerializer, NotificationSerializer, AuditLogSerializer
)
from .middleware import LoginAttemptMiddleware
from .excel_handler import ExcelValidator
import logging

logger = logging.getLogger('django')
security_logger = logging.getLogger('security')


def get_client_ip(request):
    """Get client IP address"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


def create_audit_log(user, action, details, request):
    """Create audit log entry"""
    AuditLog.objects.create(
        user=user,
        action=action,
        details=details,
        ip_address=get_client_ip(request)
    )


@api_view(['POST'])
@permission_classes([AllowAny])
def register_student(request):
    """Student registration"""
    serializer = UserRegistrationSerializer(data=request.data)
    
    if serializer.is_valid():
        user = serializer.save()
        
        # Create audit log
        create_audit_log(user, 'user_registration', 
                        f"Student registered: {user.roll_number}", request)
        
        security_logger.info(f"New student registered: {user.roll_number} from {get_client_ip(request)}")
        
        return Response({
            'message': 'Registration successful',
            'roll_number': user.roll_number
        }, status=status.HTTP_201_CREATED)
    
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([AllowAny])
def login_view(request):
    """Login for both admin and students"""
    username = request.data.get('username')
    password = request.data.get('password')
    ip_address = get_client_ip(request)
    
    if not username or not password:
        return Response({
            'error': 'Username and password are required'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Check login attempts
    if not LoginAttemptMiddleware.check_login_attempts(username, ip_address):
        security_logger.warning(f"Account locked: {username} from {ip_address}")
        return Response({
            'error': 'Account temporarily locked due to multiple failed login attempts. Please try again later.'
        }, status=status.HTTP_403_FORBIDDEN)
    
    # Authenticate user
    user = authenticate(username=username, password=password)
    
    if user is not None:
        # Clear failed attempts
        LoginAttemptMiddleware.clear_login_attempts(username)
        
        # Record successful attempt
        LoginAttemptMiddleware.record_login_attempt(username, ip_address, True)
        
        # Generate tokens
        refresh = RefreshToken.for_user(user)
        
        # Create audit log
        create_audit_log(user, 'login', f"Successful login from {ip_address}", request)
        
        security_logger.info(f"Successful login: {username} from {ip_address}")
        
        return Response({
            'refresh': str(refresh),
            'access': str(refresh.access_token),
            'user': {
                'username': user.username,
                'roll_number': user.roll_number,
                'role': user.role,
                'first_name': user.first_name,
                'last_name': user.last_name
            }
        })
    else:
        # Record failed attempt
        LoginAttemptMiddleware.record_login_attempt(username, ip_address, False)
        
        # Get remaining attempts
        remaining = LoginAttemptMiddleware.get_remaining_attempts(username)
        
        security_logger.warning(f"Failed login attempt: {username} from {ip_address}. {remaining} attempts remaining")
        
        error_message = 'Invalid credentials'
        if remaining > 0:
            error_message += f'. {remaining} attempt(s) remaining before account lockout'
        else:
            error_message = 'Account locked due to multiple failed attempts. Please try again in 30 minutes'
        
        return Response({
            'error': error_message,
            'remaining_attempts': remaining
        }, status=status.HTTP_401_UNAUTHORIZED)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout_view(request):
    """Logout and blacklist token"""
    try:
        from .models import BlacklistedToken
        
        refresh_token = request.data.get('refresh')
        access_token = request.data.get('access')
        
        # Blacklist both tokens
        if refresh_token:
            BlacklistedToken.objects.get_or_create(
                token=refresh_token,
                defaults={'user': request.user}
            )
        
        if access_token:
            BlacklistedToken.objects.get_or_create(
                token=access_token,
                defaults={'user': request.user}
            )
        
        create_audit_log(request.user, 'logout', 
                        f"Logout from {get_client_ip(request)}", request)
        
        security_logger.info(f"User logged out: {request.user.username} from {get_client_ip(request)}")
        
        return Response({'message': 'Logout successful'})
    except Exception as e:
        security_logger.error(f"Logout error: {str(e)}")
        return Response({'error': 'Logout failed'}, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def change_password(request):
    """Change password"""
    serializer = PasswordChangeSerializer(data=request.data)
    
    if serializer.is_valid():
        user = request.user
        
        # Check old password
        if not user.check_password(serializer.validated_data['old_password']):
            return Response({
                'error': 'Old password is incorrect'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Set new password
        user.set_password(serializer.validated_data['new_password'])
        user.save()
        
        # Create audit log
        create_audit_log(user, 'password_change', 
                        f"Password changed from {get_client_ip(request)}", request)
        
        security_logger.info(f"Password changed: {user.username} from {get_client_ip(request)}")
        
        return Response({'message': 'Password changed successfully'})
    
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def upload_results(request):
    """Upload results via Excel (Admin only)"""
    if request.user.role != 'admin':
        security_logger.warning(f"Unauthorized result upload attempt by {request.user.username}")
        return Response({
            'error': 'Permission denied'
        }, status=status.HTTP_403_FORBIDDEN)
    
    file = request.FILES.get('file')
    if not file:
        return Response({
            'error': 'No file provided'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Get form data
    year = request.POST.get('year')
    semester = request.POST.get('semester')
    result_type = request.POST.get('result_type')
    course = request.POST.get('course', 'btech')  # Default to btech
    exam_held_date = request.POST.get('exam_held_date')
    
    # Validate form data
    if not year or not semester or not result_type or not course:
        return Response({
            'error': 'Year, Semester, Result Type, and Course are required'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    try:
        year = int(year)
        semester = int(semester)
    except ValueError:
        return Response({
            'error': 'Year and Semester must be numbers'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if year not in [1, 2, 3, 4]:
        return Response({
            'error': 'Year must be 1, 2, 3, or 4'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    if semester not in [1, 2]:
        return Response({
            'error': 'Semester must be 1 or 2'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Normalize course
    course_lower = course.lower()
    if course_lower not in ['btech', 'mtech']:
        return Response({
            'error': 'Course must be B.Tech or M.Tech'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    course_display = 'B.Tech' if course_lower == 'btech' else 'M.Tech'
    
    # Normalize result type
    result_type_lower = result_type.lower()
    if result_type_lower not in ['regular', 'supplementary', 'both']:
        return Response({
            'error': 'Result Type must be Regular, Supplementary, or Both'
        }, status=status.HTTP_400_BAD_REQUEST)
    
    # Generate exam name
    year_text = ['I', 'II', 'III', 'IV'][year - 1]
    semester_text = ['I', 'II'][semester - 1]
    result_type_display = dict([('regular', 'Regular'), ('supplementary', 'Supplementary'), ('both', 'Regular and Supplementary')])[result_type_lower]
    
    from datetime import datetime
    exam_date_obj = None
    if exam_held_date:
        try:
            # Parse YYYY-MM format
            exam_date = datetime.strptime(exam_held_date, "%Y-%m")
            month_year = exam_date.strftime("%B %Y")
            exam_date_obj = exam_date.date()  # Convert to date object
        except:
            month_year = datetime.now().strftime("%B %Y")
    else:
        month_year = datetime.now().strftime("%B %Y")
    
    exam_name = f"{course_display} {year_text} year {semester_text} Semester {result_type_display} Exam Results {month_year}"
    # Validate file
    file_errors = ExcelValidator.validate_file(file)
    if file_errors:
        return Response({'errors': file_errors}, status=status.HTTP_400_BAD_REQUEST)
    
    # Parse Excel
    try:
        import openpyxl
        workbook = openpyxl.load_workbook(file, data_only=True)
        
        # Validate structure
        structure_errors = ExcelValidator.validate_structure(workbook)
        if structure_errors:
            return Response({'errors': structure_errors}, status=status.HTTP_400_BAD_REQUEST)
        
        # Parse data
        file.seek(0)
        data, parse_errors = ExcelValidator.parse_excel(file)
        
        if parse_errors:
            return Response({'errors': parse_errors}, status=status.HTTP_400_BAD_REQUEST)
        
        # Validate data
        validation_errors = ExcelValidator.validate_data(data)
        if validation_errors:
            return Response({'errors': validation_errors}, status=status.HTTP_400_BAD_REQUEST)
        
        # Import data
        with transaction.atomic():
            created_count = 0
            updated_count = 0
            students_notified = set()
            
            for row in data:
                roll_number = str(row['Roll Number']).strip()
                # Year, semester, exam_name, result_type come from form data now
                
                # Get or create student user
                student_user, _ = User.objects.get_or_create(
                    roll_number=roll_number,
                    defaults={
                        'username': roll_number,
                        'role': 'student'
                    }
                )
                
                # Check if result exists
                result, created = Result.objects.update_or_create(
                    roll_number=roll_number,
                    year=year,
                    semester=semester,
                    result_type=result_type_lower,
                    defaults={
                        'student': student_user,
                        'student_name': str(row['Student Name']).strip(),
                        'exam_name': exam_name,
                        'exam_held_date': exam_date_obj,
                        'course': course_lower,
                        'overall_result': row.get('Overall Result', ''),
                        'overall_grade': row.get('Overall Grade', ''),
                        'uploaded_by': request.user
                    }
                )
                
                if created:
                    created_count += 1
                else:
                    updated_count += 1
                
                # Delete existing subjects for update
                if not created:
                    result.subjects.all().delete()
                
                # Create subjects
                for subject_data in row.get('subjects', []):
                    Subject.objects.create(
                        result=result,
                        subject_code=str(subject_data.get('Code', '')).strip(),
                        subject_name=str(subject_data.get('Name', '')).strip(),
                        internal_marks=subject_data.get('Internal', None),
                        external_marks=subject_data.get('External', None),
                        total_marks=subject_data.get('Total', None),
                        subject_result=subject_data.get('Result', '').lower(),
                        grade=subject_data.get('Grade', '')
                    )
                
                # Create notification for student
                if roll_number not in students_notified:
                    from datetime import date
                    Notification.objects.create(
                        student=student_user,
                        result=result,
                        exam_name=exam_name,
                        message=f"{exam_name}",
                        results_published_date=date.today()
                    )
                    students_notified.add(roll_number)
            
            # Create audit log
            create_audit_log(
                request.user, 
                'result_upload',
                f"Uploaded results: {created_count} created, {updated_count} updated",
                request
            )
            
            security_logger.info(
                f"Results uploaded by {request.user.username}: {created_count} created, {updated_count} updated"
            )
            
            return Response({
                'message': 'Results uploaded successfully',
                'created': created_count,
                'updated': updated_count,
                'students_notified': len(students_notified)
            }, status=status.HTTP_201_CREATED)
    
    except Exception as e:
        logger.error(f"Error uploading results: {str(e)}")
        return Response({
            'error': f"Error processing file: {str(e)}"
        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_results(request):
    """Get results for logged-in student or all results for admin"""
    user = request.user
    
    if user.role == 'admin':
        # Admin can see all results
        results = Result.objects.all().order_by('-uploaded_at')
        
        # Optional filters
        roll_number = request.GET.get('roll_number')
        semester = request.GET.get('semester')
        result_type = request.GET.get('result_type')
        
        if roll_number:
            results = results.filter(roll_number__icontains=roll_number)
        if semester:
            results = results.filter(semester=semester)
        if result_type:
            results = results.filter(result_type=result_type)
    else:
        # Students can only see their own results
        results = Result.objects.filter(student=user).order_by('-uploaded_at')
    
    serializer = ResultSerializer(results, many=True)
    
    # Create audit log
    create_audit_log(user, 'result_view', 
                    f"Viewed results: {results.count()} records", request)
    
    return Response({
        'count': results.count(),
        'results': serializer.data
    })


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def get_notifications(request):
    """Get notifications for logged-in student"""
    user = request.user
    
    if user.role != 'student':
        return Response({
            'error': 'Notifications are only available for students'
        }, status=status.HTTP_403_FORBIDDEN)
    
    # Get query parameters
    unread_only = request.GET.get('unread_only', 'false').lower() == 'true'
    
    notifications = Notification.objects.filter(student=user)
    
    if unread_only:
        notifications = notifications.filter(is_read=False)
    
    serializer = NotificationSerializer(notifications, many=True)
    
    return Response({
        'count': notifications.count(),
        'unread_count': Notification.objects.filter(student=user, is_read=False).count(),
        'notifications': serializer.data
    })


@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def mark_notification_read(request, notification_id):
    """Mark notification as read"""
    user = request.user
    
    try:
        notification = Notification.objects.get(id=notification_id, student=user)
        notification.is_read = True
        notification.save()
        
        return Response({
            'message': 'Notification marked as read'
        })
    except Notification.DoesNotExist:
        return Response({
            'error': 'Notification not found'
        }, status=status.HTTP_404_NOT_FOUND)


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def health_check(request):
    """Health check endpoint"""
    try:
        # Check database connectivity
        user_count = User.objects.count()
        result_count = Result.objects.count()
        
        return Response({
            'status': 'healthy',
            'database': 'connected',
            'user': {
                'username': request.user.username,
                'role': request.user.role,
                'authenticated': True
            },
            'stats': {
                'total_users': user_count,
                'total_results': result_count
            },
            'timestamp': timezone.now().isoformat()
        })
    except Exception as e:
        logger.error(f"Health check failed: {str(e)}")
        return Response({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': timezone.now().isoformat()
        }, status=status.HTTP_503_SERVICE_UNAVAILABLE)


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def get_uploaded_exams(request):
    """Get list of uploaded exams (grouped by exam_name) - Admin only"""
    if request.user.role != "admin":
        return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
    
    from django.db.models import Count, Max, Min, F
    
    # Get unique exam names first
    exam_names = Result.objects.values_list('exam_name', flat=True).distinct()
    
    exams_list = []
    for exam_name in exam_names:
        # Get stats for this exam
        exam_results = Result.objects.filter(exam_name=exam_name)
        
        # Count unique students (by roll_number)
        student_count = exam_results.values('roll_number').distinct().count()
        
        # Get other info from first result
        first_result = exam_results.first()
        
        if first_result:
            exams_list.append({
                'exam_name': exam_name,
                'year': first_result.year,
                'semester': first_result.semester,
                'result_type': first_result.result_type,
                'course': first_result.course,
                'uploaded_at': first_result.uploaded_at,
                'uploaded_by__username': first_result.uploaded_by.username if first_result.uploaded_by else 'Unknown',
                'student_count': student_count,
                'latest_upload': exam_results.aggregate(Max('uploaded_at'))['uploaded_at__max']
            })
    
    # Sort by latest upload date
    exams_list.sort(key=lambda x: x['latest_upload'], reverse=True)
    
    return Response({
        "count": len(exams_list),
        "exams": exams_list
    })


@api_view(["GET"])
@permission_classes([IsAuthenticated])
def download_exam_results(request, exam_name):
    """Download results as Excel file for a specific exam - Admin only"""
    if request.user.role != "admin":
        return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)
    
    from django.http import HttpResponse
    import openpyxl
    from openpyxl.styles import Font, PatternFill, Alignment
    
    # Get all results for this exam
    results = Result.objects.filter(exam_name=exam_name).prefetch_related("subjects").order_by("roll_number")
    
    if not results.exists():
        return Response({"error": "No results found for this exam"}, status=status.HTTP_404_NOT_FOUND)
    
    # Create workbook
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Results"
    
    # Headers
    headers = ["Roll Number", "Student Name"]
    
    # Find maximum number of subjects
    max_subjects = max(r.subjects.count() for r in results)
    
    # Add subject columns
    for i in range(1, max_subjects + 1):
        headers.extend([
            f"Subject {i} Code", f"Subject {i} Name",
            f"Subject {i} Internal", f"Subject {i} External",
            f"Subject {i} Total", f"Subject {i} Result", f"Subject {i} Grade"
        ])
    
    headers.extend(["Overall Result", "Overall Grade"])
    
    # Write headers
    for col_idx, header in enumerate(headers, 1):
        cell = ws.cell(1, col_idx, header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
        cell.alignment = Alignment(horizontal="center", vertical="center")
    
    # Write data
    row_idx = 2
    current_roll = None
    row_data = []
    
    for result in results:
        if current_roll != result.roll_number:
            # Write previous row if exists
            if row_data:
                for col_idx, value in enumerate(row_data, 1):
                    ws.cell(row_idx, col_idx, value)
                row_idx += 1
            
            # Start new row
            row_data = [result.roll_number, result.student_name]
            current_roll = result.roll_number
        
        # Add subject data
        for subject in result.subjects.all():
            row_data.extend([
                subject.subject_code, subject.subject_name,
                subject.internal_marks, subject.external_marks,
                subject.total_marks, subject.subject_result, subject.grade
            ])
        
        # Add overall result (only once per student)
        if not any(x in row_data[2:] for x in [result.overall_result, result.overall_grade]):
            row_data.extend([result.overall_result, result.overall_grade])
    
    # Write last row
    if row_data:
        for col_idx, value in enumerate(row_data, 1):
            ws.cell(row_idx, col_idx, value)
    
    # Adjust column widths
    for col in ws.columns:
        max_length = 0
        column = col[0].column_letter
        for cell in col:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(str(cell.value))
            except:
                pass
        adjusted_width = min(max_length + 2, 50)
        ws.column_dimensions[column].width = adjusted_width
    
    # Create response
    response = HttpResponse(
        content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )
    filename = exam_name.replace(" ", "_")
    response["Content-Disposition"] = f"attachment; filename={filename}.xlsx"
    
    wb.save(response)
    return response


@api_view(['DELETE'])
@permission_classes([IsAuthenticated])
def delete_exam_results(request, exam_name):
    """Delete all results for a specific exam - Admin only"""
    if request.user.role != 'admin':
        return Response({'error': 'Permission denied'}, status=status.HTTP_403_FORBIDDEN)
    
    # Get all results for this exam
    results = Result.objects.filter(exam_name=exam_name)
    
    if not results.exists():
        return Response({'error': 'No results found for this exam'}, status=status.HTTP_404_NOT_FOUND)
    
    # Count before deletion
    count = results.count()
    student_count = results.values('roll_number').distinct().count()
    
    # Delete all results (subjects will be cascade deleted)
    results.delete()
    
    # Delete associated notifications
    Notification.objects.filter(exam_name=exam_name).delete()
    
    # Create audit log
    create_audit_log(
        request.user,
        'DELETE_EXAM',
        f'Deleted exam: {exam_name} ({student_count} students, {count} total records)',
        request
    )
    
    logger.info(f'Admin {request.user.username} deleted exam: {exam_name}')
    
    return Response({
        'message': f'Successfully deleted {exam_name}',
        'students_deleted': student_count,
        'records_deleted': count
    }, status=status.HTTP_200_OK)
